# Context: So far we’ve created a static server and one API server, each of which has its own Docker images and runs in different Docker containers. 
# This is okay, but this means that we have to keep track of two separate locations. If we change the port that the API server is using,
# then we’d have to change the client to hit that new port; in this case ports on our computer, but it would be IP addresses if these were external servers. 
# This is not ideal, especially if you have many different clients that you’d need to update and deploy.


# Instead, let’s put a server in front of our static server and API server that acts as a proxy between the client and our full application. 
# Clients (in this case the web browser) will only have to know about the proxy server’s location and our front-end can also simply hit the same proxy server, rather than 
# going to the API directly, to then be routed to the API server in order to get dynamic data from it.

server {
    listen 80;

    location / {
        proxy_pass http://front-end:9000;
    }

    location /api {
        proxy_pass http://back-end:5252;
    }
}